import { useIsomorphicLayoutEffect } from "@tamagui/constants";
import { getBoundingClientRect } from "../helpers/getBoundingClientRect";
function _array_like_to_array(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _array_with_holes(arr) {
  if (Array.isArray(arr)) return arr;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg), value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  info.done ? resolve(value) : Promise.resolve(value).then(_next, _throw);
}
function _async_to_generator(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
function _instanceof(left, right) {
  return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
}
function _iterable_to_array_limit(arr, i) {
  var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i != null) {
    var _arr = [], _n = !0, _d = !1, _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
        ;
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        !_n && _i.return != null && _i.return();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
}
function _non_iterable_rest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _sliced_to_array(arr, i) {
  return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();
}
function _type_of(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array(o, minLen) {
  if (o) {
    if (typeof o == "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
  }
}
function _ts_generator(thisArg, body) {
  var f, y, t, g, _ = {
    label: 0,
    sent: function() {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  };
  return g = {
    next: verb(0),
    throw: verb(1),
    return: verb(2)
  }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([
        n,
        v
      ]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    for (; _; ) try {
      if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      switch (y = 0, t && (op = [
        op[0] & 2,
        t.value
      ]), op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          return _.label++, {
            value: op[1],
            done: !1
          };
        case 5:
          _.label++, y = op[1], op = [
            0
          ];
          continue;
        case 7:
          op = _.ops.pop(), _.trys.pop();
          continue;
        default:
          if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1], t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2], _.ops.push(op);
            break;
          }
          t[2] && _.ops.pop(), _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [
        6,
        e
      ], y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: !0
    };
  }
}
var LayoutHandlers = /* @__PURE__ */ new WeakMap(), resizeListeners = /* @__PURE__ */ new Set(), resizeObserver = null;
if (typeof window < "u" && "ResizeObserver" in window && (resizeObserver = new ResizeObserver(function(entries) {
  var _iteratorNormalCompletion = !0, _didIteratorError = !1, _iteratorError = void 0;
  try {
    for (var _loop = function() {
      var target = _step.value.target, onLayout = LayoutHandlers.get(target);
      if (typeof onLayout != "function") return {
        v: void 0
      };
      measureElement(target).then(function(event) {
        onLayout(event);
      });
    }, _iterator = entries[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) {
      var _ret = _loop();
      if (_type_of(_ret) === "object") return _ret.v;
    }
  } catch (err) {
    _didIteratorError = !0, _iteratorError = err;
  } finally {
    try {
      !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
    } finally {
      if (_didIteratorError)
        throw _iteratorError;
    }
  }
}), typeof window.addEventListener == "function")) {
  var tm;
  window.addEventListener("resize", function() {
    clearTimeout(tm), tm = setTimeout(function() {
      resizeListeners.forEach(function(cb) {
        return cb();
      });
    }, 4);
  });
}
var measureElement = function() {
  var _ref = _async_to_generator(function(target) {
    return _ts_generator(this, function(_state) {
      return [
        2,
        new Promise(function(res) {
          measureLayout(target, null, function(x, y, width, height, left, top) {
            res({
              nativeEvent: {
                layout: {
                  x,
                  y,
                  width,
                  height,
                  left,
                  top
                },
                target
              },
              timeStamp: Date.now()
            });
          });
        })
      ];
    });
  });
  return function(target) {
    return _ref.apply(this, arguments);
  };
}(), cache = /* @__PURE__ */ new WeakMap(), measureLayout = function(node, relativeTo, callback) {
  var relativeNode = relativeTo || (node == null ? void 0 : node.parentNode);
  if (_instanceof(relativeNode, HTMLElement)) {
    var now = Date.now();
    cache.set(node, now), Promise.all([
      getBoundingClientRectAsync(node),
      getBoundingClientRectAsync(relativeNode)
    ]).then(function(param) {
      var _param = _sliced_to_array(param, 2), nodeDim = _param[0], relativeNodeDim = _param[1];
      if (relativeNodeDim && nodeDim && cache.get(node) === now) {
        var _getRelativeDimensions = getRelativeDimensions(nodeDim, relativeNodeDim), x = _getRelativeDimensions.x, y = _getRelativeDimensions.y, width = _getRelativeDimensions.width, height = _getRelativeDimensions.height, left = _getRelativeDimensions.left, top = _getRelativeDimensions.top;
        callback(x, y, width, height, left, top);
      }
    });
  }
}, getRelativeDimensions = function(a, b) {
  var height = a.height, left = a.left, top = a.top, width = a.width, x = left - b.left, y = top - b.top;
  return {
    x,
    y,
    width,
    height,
    left,
    top
  };
}, getBoundingClientRectAsync = function(element) {
  return new Promise(function(resolve) {
    var fallbackToSync = function() {
      resolve(getBoundingClientRect(element));
    }, tm = setTimeout(fallbackToSync, 10), observer = new IntersectionObserver(function(entries, ob) {
      var _entries_;
      clearTimeout(tm), ob.disconnect(), resolve((_entries_ = entries[0]) === null || _entries_ === void 0 ? void 0 : _entries_.boundingClientRect);
    }, {
      threshold: 1e-4
    });
    observer.observe(element);
  });
};
function useElementLayout(ref, onLayout) {
  useIsomorphicLayoutEffect(function() {
    if (onLayout) {
      var node = ref.current;
      node && LayoutHandlers.set(node, onLayout);
    }
  }, [
    ref,
    onLayout
  ]), useIsomorphicLayoutEffect(function() {
    if (resizeObserver) {
      var node = ref.current;
      if (node && LayoutHandlers.has(node)) {
        var onResize = function() {
          measureElement(node).then(onLayout);
        };
        return resizeListeners.add(onResize), resizeObserver.observe(node), function() {
          resizeListeners.delete(onResize), resizeObserver == null || resizeObserver.unobserve(node);
        };
      }
    }
  }, [
    ref
  ]);
}
export {
  measureElement,
  measureLayout,
  useElementLayout
};
//# sourceMappingURL=useElementLayout.js.map
