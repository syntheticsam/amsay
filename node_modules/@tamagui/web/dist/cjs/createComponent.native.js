"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var createComponent_exports = {};
__export(createComponent_exports, {
  Spacer: () => Spacer,
  Unspaced: () => Unspaced,
  componentSetStates: () => componentSetStates,
  createComponent: () => createComponent,
  isDisabled: () => isDisabled,
  spacedChildren: () => spacedChildren,
  subscribeToContextGroup: () => subscribeToContextGroup,
  useComponentState: () => useComponentState
});
module.exports = __toCommonJS(createComponent_exports);
var import_jsx_runtime = require("react/jsx-runtime"), import_compose_refs = require("@tamagui/compose-refs"), import_constants = require("@tamagui/constants"), import_helpers = require("@tamagui/helpers"), import_react = __toESM(require("react")), import_config = require("./config"), import_constants2 = require("./constants/constants"), import_isDevTools = require("./constants/isDevTools"), import_ComponentContext = require("./contexts/ComponentContext"), import_createVariable = require("./createVariable"), import_defaultComponentState = require("./defaultComponentState"), import_createShallowSetState = require("./helpers/createShallowSetState"), import_getSplitStyles = require("./helpers/getSplitStyles"), import_isObj = require("./helpers/isObj"), import_log = require("./helpers/log"), import_mergeProps = require("./helpers/mergeProps"), import_setElementProps = require("./helpers/setElementProps"), import_themeable = require("./helpers/themeable"), import_useMedia = require("./hooks/useMedia"), import_useTheme = require("./hooks/useTheme"), import_setupHooks = require("./setupHooks"), import_Slot = require("./views/Slot"), import_Theme = require("./views/Theme"), import_ThemeDebug = require("./views/ThemeDebug"), import_useDidHydrateOnce = require("./hooks/useDidHydrateOnce");
function _array_like_to_array(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _array_with_holes(arr) {
  if (Array.isArray(arr)) return arr;
}
function _array_without_holes(arr) {
  if (Array.isArray(arr)) return _array_like_to_array(arr);
}
function _define_property(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
function _iterable_to_array(iter) {
  if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _iterable_to_array_limit(arr, i) {
  var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i != null) {
    var _arr = [], _n = !0, _d = !1, _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
        ;
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        !_n && _i.return != null && _i.return();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
}
function _non_iterable_rest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _non_iterable_spread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _object_spread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {}, ownKeys2 = Object.keys(source);
    typeof Object.getOwnPropertySymbols == "function" && (ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
      return Object.getOwnPropertyDescriptor(source, sym).enumerable;
    }))), ownKeys2.forEach(function(key) {
      _define_property(target, key, source[key]);
    });
  }
  return target;
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _object_spread_props(target, source) {
  return source = source ?? {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
  }), target;
}
function _object_without_properties(source, excluded) {
  if (source == null) return {};
  var target = _object_without_properties_loose(source, excluded), key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++)
      key = sourceSymbolKeys[i], !(excluded.indexOf(key) >= 0) && Object.prototype.propertyIsEnumerable.call(source, key) && (target[key] = source[key]);
  }
  return target;
}
function _object_without_properties_loose(source, excluded) {
  if (source == null) return {};
  var target = {}, sourceKeys = Object.keys(source), key, i;
  for (i = 0; i < sourceKeys.length; i++)
    key = sourceKeys[i], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
  return target;
}
function _sliced_to_array(arr, i) {
  return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();
}
function _tagged_template_literal(strings, raw) {
  return raw || (raw = strings.slice(0)), Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
}
function _to_consumable_array(arr) {
  return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _unsupported_iterable_to_array(o, minLen) {
  if (o) {
    if (typeof o == "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
  }
}
function _templateObject() {
  var data = _tagged_template_literal([
    "pre-use-state"
  ]);
  return _templateObject = function() {
    return data;
  }, data;
}
function _templateObject1() {
  var data = _tagged_template_literal([
    "start (ignore)"
  ]);
  return _templateObject1 = function() {
    return data;
  }, data;
}
function _templateObject2() {
  var data = _tagged_template_literal([
    "did-finish-ssr"
  ]);
  return _templateObject2 = function() {
    return data;
  }, data;
}
function _templateObject3() {
  var data = _tagged_template_literal([
    "stateref"
  ]);
  return _templateObject3 = function() {
    return data;
  }, data;
}
function _templateObject4() {
  var data = _tagged_template_literal([
    "use-state"
  ]);
  return _templateObject4 = function() {
    return data;
  }, data;
}
function _templateObject5() {
  var data = _tagged_template_literal([
    "use-context"
  ]);
  return _templateObject5 = function() {
    return data;
  }, data;
}
function _templateObject6() {
  var data = _tagged_template_literal([
    "theme-props"
  ]);
  return _templateObject6 = function() {
    return data;
  }, data;
}
function _templateObject7() {
  var data = _tagged_template_literal([
    "pre-theme-media"
  ]);
  return _templateObject7 = function() {
    return data;
  }, data;
}
function _templateObject8() {
  var data = _tagged_template_literal([
    "theme"
  ]);
  return _templateObject8 = function() {
    return data;
  }, data;
}
function _templateObject9() {
  var data = _tagged_template_literal([
    "media"
  ]);
  return _templateObject9 = function() {
    return data;
  }, data;
}
function _templateObject10() {
  var data = _tagged_template_literal([
    "split-styles"
  ]);
  return _templateObject10 = function() {
    return data;
  }, data;
}
function _templateObject11() {
  var data = _tagged_template_literal([
    "animations"
  ]);
  return _templateObject11 = function() {
    return data;
  }, data;
}
function _templateObject12() {
  var data = _tagged_template_literal([
    "destructure"
  ]);
  return _templateObject12 = function() {
    return data;
  }, data;
}
function _templateObject13() {
  var data = _tagged_template_literal([
    "events-hooks"
  ]);
  return _templateObject13 = function() {
    return data;
  }, data;
}
function _templateObject14() {
  var data = _tagged_template_literal([
    "events-setup"
  ]);
  return _templateObject14 = function() {
    return data;
  }, data;
}
function _templateObject15() {
  var data = _tagged_template_literal([
    "events"
  ]);
  return _templateObject15 = function() {
    return data;
  }, data;
}
function _templateObject16() {
  var data = _tagged_template_literal([
    "hooks"
  ]);
  return _templateObject16 = function() {
    return data;
  }, data;
}
function _templateObject17() {
  var data = _tagged_template_literal([
    "spaced-as-child"
  ]);
  return _templateObject17 = function() {
    return data;
  }, data;
}
function _templateObject18() {
  var data = _tagged_template_literal([
    "create-element"
  ]);
  return _templateObject18 = function() {
    return data;
  }, data;
}
function _templateObject19() {
  var data = _tagged_template_literal([
    "group-context"
  ]);
  return _templateObject19 = function() {
    return data;
  }, data;
}
function _templateObject20() {
  var data = _tagged_template_literal([
    "themed-children"
  ]);
  return _templateObject20 = function() {
    return data;
  }, data;
}
function _templateObject21() {
  var data = _tagged_template_literal([
    "rest"
  ]);
  return _templateObject21 = function() {
    return data;
  }, data;
}
var tamaguiConfig, time, debugKeyListeners, startVisualizer, componentSetStates = /* @__PURE__ */ new Set();
if (typeof document < "u") {
  var cancelTouches = function() {
    componentSetStates.forEach(function(setState) {
      return setState(function(prev) {
        return prev.press || prev.pressIn ? _object_spread_props(_object_spread({}, prev), {
          press: !1,
          pressIn: !1
        }) : prev;
      });
    }), componentSetStates.clear();
  };
  addEventListener("mouseup", cancelTouches), addEventListener("touchend", cancelTouches), addEventListener("touchcancel", cancelTouches), process.env.NODE_ENV === "development" && (startVisualizer = function() {
    var devVisualizerConfig = import_config.devConfig === null || import_config.devConfig === void 0 ? void 0 : import_config.devConfig.visualizer;
    if (devVisualizerConfig) {
      debugKeyListeners = /* @__PURE__ */ new Set();
      var tm, isShowing = !1, options = _object_spread({
        key: "Alt",
        delay: 800
      }, typeof devVisualizerConfig == "object" ? devVisualizerConfig : {});
      document.addEventListener("blur", function() {
        clearTimeout(tm);
      }), document.addEventListener("keydown", function(param) {
        var key = param.key, defaultPrevented = param.defaultPrevented;
        defaultPrevented || (clearTimeout(tm), key === options.key && (tm = setTimeout(function() {
          isShowing = !0, debugKeyListeners == null || debugKeyListeners.forEach(function(l) {
            return l(!0);
          });
        }, options.delay)));
      }), document.addEventListener("keyup", function(param) {
        var key = param.key, defaultPrevented = param.defaultPrevented;
        defaultPrevented || key === options.key && (clearTimeout(tm), isShowing && (debugKeyListeners == null || debugKeyListeners.forEach(function(l) {
          return l(!1);
        })));
      });
    }
  });
}
var useComponentState = function(props, param, staticConfig, config) {
  var animationDriver = param.animationDriver, groups = param.groups, _animationDriver_usePresence, useAnimations = animationDriver == null ? void 0 : animationDriver.useAnimations, stateRef = (0, import_react.useRef)({}), hasAnimationProp = !!("animation" in props || props.style && hasAnimatedStyleValue(props.style)), supportsCSSVars = animationDriver == null ? void 0 : animationDriver.supportsCSSVars, curStateRef = stateRef.current, willBeAnimatedClient = function() {
    var next = !!(hasAnimationProp && !staticConfig.isHOC && useAnimations);
    return !!(next || curStateRef.hasAnimated);
  }(), willBeAnimated = !import_constants.isServer && willBeAnimatedClient;
  willBeAnimated && !curStateRef.hasAnimated && (curStateRef.hasAnimated = !0);
  var presence = willBeAnimated && props.animatePresence !== !1 && (animationDriver == null || (_animationDriver_usePresence = animationDriver.usePresence) === null || _animationDriver_usePresence === void 0 ? void 0 : _animationDriver_usePresence.call(animationDriver)) || null, presenceState = presence == null ? void 0 : presence[2], isExiting = (presenceState == null ? void 0 : presenceState.isPresent) === !1, isEntering = (presenceState == null ? void 0 : presenceState.isPresent) === !0 && presenceState.initial !== !1, hasEnterStyle = !!props.enterStyle, hasRNAnimation = hasAnimationProp && (animationDriver == null ? void 0 : animationDriver.isReactNative);
  process.env.NODE_ENV === "development" && time && time(_templateObject());
  var hasEnterState = hasEnterStyle || isEntering, didHydrateOnce = (0, import_useDidHydrateOnce.useDidHydrateOnce)(), initialState = hasEnterState || !didHydrateOnce && hasRNAnimation ? (
    // on the very first render we switch all spring animation drivers to css rendering
    // this is because we need to use css variables, which they don't support to do proper SSR
    // without flickers of the wrong colors.
    // but once we do that initial hydration and we are in client side rendering mode,
    // we can avoid the extra re-render on mount
    import_constants.isWeb && !didHydrateOnce ? import_defaultComponentState.defaultComponentState : import_defaultComponentState.defaultComponentStateShouldEnter
  ) : import_defaultComponentState.defaultComponentStateMounted, disabled = isDisabled(props);
  disabled != null && (initialState.disabled = disabled);
  var states = (0, import_react.useState)(initialState), state = props.forceStyle ? _object_spread_props(_object_spread({}, states[0]), _define_property({}, props.forceStyle, !0)) : states[0], setState = states[1], isHydrated = state.unmounted === !1 || state.unmounted === "should-enter", isAnimated = willBeAnimated;
  import_constants.isWeb && hasRNAnimation && !staticConfig.isHOC && state.unmounted === !0 && (isAnimated = !1, curStateRef.willHydrate = !0), disabled !== state.disabled && (state.disabled = disabled, disabled && Object.assign(state, import_defaultComponentState.defaultComponentStateMounted), setState(_object_spread({}, state)));
  var setStateShallow = (0, import_createShallowSetState.createShallowSetState)(setState, disabled, !1, props.debug);
  if (presenceState && isAnimated && isHydrated && staticConfig.variants) {
    process.env.NODE_ENV === "development" && props.debug === "verbose" && console.warn("has presenceState ".concat(JSON.stringify(presenceState)));
    var enterVariant = presenceState.enterVariant, exitVariant = presenceState.exitVariant, enterExitVariant = presenceState.enterExitVariant, custom = presenceState.custom;
    (0, import_isObj.isObj)(custom) && Object.assign(props, custom);
    var exv = exitVariant ?? enterExitVariant, env = enterVariant ?? enterExitVariant;
    state.unmounted && env && staticConfig.variants[env] ? (process.env.NODE_ENV === "development" && props.debug === "verbose" && console.warn('Animating presence ENTER "'.concat(env, '"')), props[env] = !0) : isExiting && exv && (process.env.NODE_ENV === "development" && props.debug === "verbose" && console.warn('Animating presence EXIT "'.concat(exv, '"')), props[exv] = exitVariant !== enterExitVariant);
  }
  var shouldAvoidClasses = !!(!import_constants.isWeb || isAnimated && !supportsCSSVars || !staticConfig.acceptsClassName || // on server for SSR and animation compat added the && isHydrated but perhaps we want
  // disableClassName="until-hydrated" to be more straightforward
  // see issue if not, Button sets disableClassName to true <Button animation="" /> with
  // the react-native driver errors because it tries to animate var(--color) to rbga(..)
  props.disableClassName && isHydrated), groupName = props.group;
  if (groupName && !curStateRef.group) {
    var listeners = /* @__PURE__ */ new Set();
    curStateRef.group = {
      listeners,
      emit: function(name, state2) {
        listeners.forEach(function(l) {
          return l(name, state2);
        });
      },
      subscribe: function(cb) {
        return listeners.add(cb), function() {
          listeners.delete(cb);
        };
      }
    };
  }
  if (groupName) {
    var groupContextState = groups.state, og = setStateShallow;
    setStateShallow = function(state2) {
      og(state2), curStateRef.group.emit(groupName, {
        pseudo: state2
      });
      var next = _object_spread({}, groupContextState[groupName], state2);
      groupContextState[groupName] = next;
    };
  }
  return {
    curStateRef,
    disabled,
    groupName,
    hasAnimationProp,
    hasEnterStyle,
    isAnimated,
    isExiting,
    isHydrated,
    presence,
    presenceState,
    setState,
    setStateShallow,
    shouldAvoidClasses,
    state,
    stateRef,
    supportsCSSVars,
    willBeAnimated,
    willBeAnimatedClient
  };
}, BaseText, BaseView, hasSetupBaseViews = !1, lastInteractionWasKeyboard = {
  value: !1
};
import_constants.isWeb && globalThis.document && (document.addEventListener("keydown", function() {
  lastInteractionWasKeyboard.value = !0;
}), document.addEventListener("mousedown", function() {
  lastInteractionWasKeyboard.value = !1;
}), document.addEventListener("mousemove", function() {
  lastInteractionWasKeyboard.value = !1;
}));
function createComponent(staticConfig) {
  var _staticConfig_defaultProps, componentName = staticConfig.componentName, config = null, defaultProps = staticConfig.defaultProps;
  (0, import_config.onConfiguredOnce)(function(conf) {
    if (config = conf, componentName) {
      var _conf_defaultProps, defaultForComponent = (_conf_defaultProps = conf.defaultProps) === null || _conf_defaultProps === void 0 ? void 0 : _conf_defaultProps[componentName];
      defaultForComponent && (defaultProps = _object_spread({}, defaultForComponent, defaultProps));
    }
  });
  var Component = staticConfig.Component, isText = staticConfig.isText, isZStack = staticConfig.isZStack, isHOC = staticConfig.isHOC, _staticConfig_validStyles = staticConfig.validStyles, _$validStyles = _staticConfig_validStyles === void 0 ? {} : _staticConfig_validStyles, _staticConfig_variants = staticConfig.variants, variants = _staticConfig_variants === void 0 ? {} : _staticConfig_variants;
  process.env.NODE_ENV === "development" && (!((_staticConfig_defaultProps = staticConfig.defaultProps) === null || _staticConfig_defaultProps === void 0) && _staticConfig_defaultProps.debug) && process.env.IS_STATIC !== "is_static" && (0, import_log.log)("\u{1F41B} [".concat(componentName || "Component", "]"), {
    staticConfig,
    defaultProps,
    defaultPropsKeyOrder: defaultProps ? Object.keys(defaultProps) : []
  });
  var component = /* @__PURE__ */ (0, import_react.forwardRef)(function(propsIn, forwardedRef) {
    var _themeState_state, _hooks_usePropsTransform, _hooks_useEvents, _config_animations, internalID = process.env.NODE_ENV === "development" ? (0, import_react.useId)() : "";
    if (process.env.NODE_ENV === "development" && startVisualizer && (startVisualizer(), startVisualizer = void 0), !hasSetupBaseViews) {
      var _hooks_getBaseViews;
      hasSetupBaseViews = !0;
      var baseViews = (_hooks_getBaseViews = import_setupHooks.hooks.getBaseViews) === null || _hooks_getBaseViews === void 0 ? void 0 : _hooks_getBaseViews.call(import_setupHooks.hooks);
      baseViews && (BaseText = baseViews.Text, BaseView = baseViews.View);
    }
    if (process.env.NODE_ENV === "test" && propsIn["data-test-renders"]) {
      var _propsIn_datatestrenders, _current, _;
      (_ = (_propsIn_datatestrenders = propsIn["data-test-renders"])[_current = "current"]) !== null && _ !== void 0 || (_propsIn_datatestrenders[_current] = 0), propsIn["data-test-renders"].current += 1;
    }
    var componentContext = (0, import_react.useContext)(import_ComponentContext.ComponentContext), styledContextProps, overriddenContextProps, contextValue, context = staticConfig.context, isReactNative = staticConfig.isReactNative;
    if (context) {
      contextValue = (0, import_react.useContext)(context);
      var inverseShorthands = (0, import_config.getConfig)().inverseShorthands;
      for (var key in context.props) {
        var _propsIn_key, _ref, _ref1, propVal = (_ref1 = (_ref = (_propsIn_key = propsIn[key]) !== null && _propsIn_key !== void 0 ? _propsIn_key : propsIn[inverseShorthands[key]]) !== null && _ref !== void 0 ? _ref : defaultProps == null ? void 0 : defaultProps[key]) !== null && _ref1 !== void 0 ? _ref1 : defaultProps == null ? void 0 : defaultProps[inverseShorthands[key]];
        if (propVal === void 0) {
          if (contextValue) {
            var isValidValue = key in _$validStyles || key in variants;
            isValidValue && (styledContextProps || (styledContextProps = {}), styledContextProps[key] = contextValue[key]);
          }
        } else
          overriddenContextProps || (overriddenContextProps = {}), overriddenContextProps[key] = propVal;
      }
    }
    var curDefaultProps = styledContextProps ? _object_spread({}, defaultProps, styledContextProps) : defaultProps, props = propsIn;
    curDefaultProps && (props = (0, import_mergeProps.mergeProps)(curDefaultProps, propsIn));
    var debugProp = props.debug, componentName2 = props.componentName || staticConfig.componentName;
    if (process.env.NODE_ENV === "development" && import_constants.isClient && (0, import_react.useEffect)(function() {
      var overlay = null, debugVisualizerHandler = function() {
        var show = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, node = curStateRef.host;
        if (node)
          if (show) {
            overlay = document.createElement("span"), overlay.style.inset = "0px", overlay.style.zIndex = "1000000", overlay.style.position = "absolute", overlay.style.borderColor = "red", overlay.style.borderWidth = "1px", overlay.style.borderStyle = "dotted";
            var dataAt = node.getAttribute("data-at") || "", dataIn = node.getAttribute("data-in") || "", tooltip = document.createElement("span");
            tooltip.style.position = "absolute", tooltip.style.top = "0px", tooltip.style.left = "0px", tooltip.style.padding = "3px", tooltip.style.background = "rgba(0,0,0,0.75)", tooltip.style.color = "rgba(255,255,255,1)", tooltip.style.fontSize = "12px", tooltip.style.lineHeight = "12px", tooltip.style.fontFamily = "monospace", tooltip.style.webkitFontSmoothing = "none", tooltip.innerText = "".concat(componentName2 || "", " ").concat(dataAt, " ").concat(dataIn).trim(), overlay.appendChild(tooltip), node.appendChild(overlay);
          } else
            overlay && node.removeChild(overlay);
      };
      return debugKeyListeners || (debugKeyListeners = /* @__PURE__ */ new Set()), debugKeyListeners.add(debugVisualizerHandler), function() {
        debugKeyListeners == null || debugKeyListeners.delete(debugVisualizerHandler);
      };
    }, [
      componentName2
    ]), !process.env.TAMAGUI_IS_CORE_NODE && process.env.NODE_ENV === "development" && debugProp === "profile" && !time) {
      var timer = require("@tamagui/timer").timer();
      time = timer.start();
    }
    process.env.NODE_ENV === "development" && time && time(_templateObject1()), process.env.NODE_ENV === "development" && time && time(_templateObject2()), process.env.NODE_ENV === "development" && time && time(_templateObject3());
    var animationDriver = componentContext.animationDriver, useAnimations = animationDriver == null ? void 0 : animationDriver.useAnimations, _useComponentState = useComponentState(props, componentContext, staticConfig, config), curStateRef = _useComponentState.curStateRef, disabled = _useComponentState.disabled, groupName = _useComponentState.groupName, hasAnimationProp = _useComponentState.hasAnimationProp, hasEnterStyle = _useComponentState.hasEnterStyle, isAnimated = _useComponentState.isAnimated, isExiting = _useComponentState.isExiting, isHydrated = _useComponentState.isHydrated, presence = _useComponentState.presence, presenceState = _useComponentState.presenceState, setState = _useComponentState.setState, setStateShallow = _useComponentState.setStateShallow, shouldAvoidClasses = _useComponentState.shouldAvoidClasses, state = _useComponentState.state, stateRef = _useComponentState.stateRef, supportsCSSVars = _useComponentState.supportsCSSVars, willBeAnimated = _useComponentState.willBeAnimated, willBeAnimatedClient = _useComponentState.willBeAnimatedClient, shouldForcePseudo = !!propsIn.forceStyle, noClassNames = shouldAvoidClasses || shouldForcePseudo;
    process.env.NODE_ENV === "development" && time && time(_templateObject4());
    var hasTextAncestor = !!(import_constants.isWeb && isText && componentContext.inText);
    process.env.NODE_ENV === "development" && time && time(_templateObject5());
    var isTaggable = !Component || typeof Component == "string", tagProp = props.tag, element = import_constants.isWeb && isTaggable && tagProp || Component, BaseTextComponent = BaseText || element || "span", BaseViewComponent = BaseView || element || (hasTextAncestor ? "span" : "div"), elementType = isText ? BaseTextComponent : BaseViewComponent;
    animationDriver && isAnimated && (elementType = animationDriver[isText ? "Text" : "View"] || elementType);
    var disableThemeProp = !1, disableTheme = disableThemeProp || isHOC;
    process.env.NODE_ENV === "development" && time && time(_templateObject6()), props.themeShallow && (curStateRef.themeShallow = !0);
    var themeStateProps = {
      componentName: componentName2,
      disable: disableTheme,
      shallow: curStateRef.themeShallow,
      debug: debugProp
    };
    if ("themeInverse" in props && (themeStateProps.inverse = props.themeInverse), "theme" in props && (themeStateProps.name = props.theme), typeof curStateRef.isListeningToTheme == "boolean" && (themeStateProps.shouldUpdate = function() {
      return stateRef.current.isListeningToTheme;
    }), themeStateProps.deopt = willBeAnimated, process.env.NODE_ENV === "development" && debugProp && debugProp !== "profile") {
      var name = "".concat(componentName2 || (Component == null ? void 0 : Component.displayName) || (Component == null ? void 0 : Component.name) || "[Unnamed Component]"), type = (hasEnterStyle ? "(hasEnter)" : "") + (isAnimated ? "(animated)" : "") + (isReactNative ? "(rnw)" : "") + ((presenceState == null ? void 0 : presenceState.isPresent) === !1 ? "(EXIT)" : ""), dataIs = propsIn["data-is"] || "", banner = "".concat(internalID, " ").concat(name).concat(dataIs ? " ".concat(dataIs) : "", " ").concat(type);
      if (console.info("%c ".concat(banner, " (hydrated: ").concat(isHydrated, ") (unmounted: ").concat(state.unmounted, ")"), "background: green; color: white;"), import_constants.isServer)
        (0, import_log.log)({
          noClassNames,
          isAnimated,
          shouldAvoidClasses,
          isWeb: import_constants.isWeb,
          supportsCSSVars
        });
      else {
        console.groupEnd();
        var pressLog = "".concat(state.press || state.pressIn ? " PRESS " : ""), stateLog = "".concat(pressLog).concat(state.hover ? " HOVER " : "").concat(state.focus ? " FOCUS" : " "), ch = propsIn.children, childLog = typeof ch == "string" ? ch.length > 4 ? ch.slice(0, 4) + "..." : ch : "";
        childLog.length && (childLog = "(children: ".concat(childLog, ")")), console.groupCollapsed("".concat(childLog).concat(stateLog, "Props:")), (0, import_log.log)("props in:", propsIn), (0, import_log.log)("final props:", props), (0, import_log.log)({
          state,
          staticConfig,
          elementType,
          themeStateProps
        }), (0, import_log.log)({
          contextProps: styledContextProps,
          overriddenContextProps
        }), (0, import_log.log)({
          presence,
          isAnimated,
          isHOC,
          hasAnimationProp,
          useAnimations
        }), console.groupEnd();
      }
    }
    process.env.NODE_ENV === "development" && time && time(_templateObject7());
    var _useThemeWithState = _sliced_to_array((0, import_useTheme.useThemeWithState)(themeStateProps), 2), themeState = _useThemeWithState[0], theme = _useThemeWithState[1];
    elementType = Component || elementType;
    var isStringElement = typeof elementType == "string";
    process.env.NODE_ENV === "development" && time && time(_templateObject8());
    var mediaState = (0, import_useMedia.useMedia)(stateRef, componentContext);
    (0, import_createVariable.setDidGetVariableValue)(!1), process.env.NODE_ENV === "development" && time && time(_templateObject9());
    var resolveValues = (
      // if HOC + mounted + has animation prop, resolve as value so it passes non-variable to child
      isAnimated && !supportsCSSVars || isHOC && state.unmounted == !1 && hasAnimationProp ? "value" : "auto"
    ), styleProps = {
      mediaState,
      noClassNames,
      resolveValues,
      isExiting,
      isAnimated
    }, splitStyles = (0, import_getSplitStyles.useSplitStyles)(props, staticConfig, theme, (themeState == null || (_themeState_state = themeState.state) === null || _themeState_state === void 0 ? void 0 : _themeState_state.name) || "", state, styleProps, null, componentContext, elementType, debugProp);
    if (props.group && props.untilMeasured === "hide" && !curStateRef.hasMeasured) {
      var _splitStyles;
      (_splitStyles = splitStyles).style || (_splitStyles.style = {}), splitStyles.style.opacity = 0;
    }
    process.env.NODE_ENV === "development" && time && time(_templateObject10()), curStateRef.isListeningToTheme = splitStyles.dynamicThemeAccess;
    var isMediaArray = splitStyles.hasMedia && Array.isArray(splitStyles.hasMedia), shouldListenForMedia = (0, import_createVariable.didGetVariableValue)() || isMediaArray || noClassNames && splitStyles.hasMedia === !0, mediaListeningKeys = isMediaArray ? splitStyles.hasMedia : null;
    (0, import_useMedia.setMediaShouldUpdate)(stateRef, {
      enabled: shouldListenForMedia,
      keys: mediaListeningKeys
    });
    var viewPropsIn = splitStyles.viewProps, pseudos = splitStyles.pseudos, splitStylesStyle = splitStyles.style, classNames = splitStyles.classNames, space = splitStyles.space, propsWithAnimation = props, asChild = viewPropsIn.asChild, children = viewPropsIn.children, themeShallow = viewPropsIn.themeShallow, _spaceDirection = viewPropsIn.spaceDirection, onPress = viewPropsIn.onPress, onLongPress = viewPropsIn.onLongPress, onPressIn = viewPropsIn.onPressIn, onPressOut = viewPropsIn.onPressOut, onHoverIn = viewPropsIn.onHoverIn, onHoverOut = viewPropsIn.onHoverOut, onMouseUp = viewPropsIn.onMouseUp, onMouseDown = viewPropsIn.onMouseDown, onMouseEnter = viewPropsIn.onMouseEnter, onMouseLeave = viewPropsIn.onMouseLeave, onFocus = viewPropsIn.onFocus, onBlur = viewPropsIn.onBlur, separator = viewPropsIn.separator, _forceStyle = viewPropsIn.forceStyle, onClick = viewPropsIn.onClick, _themeProp = viewPropsIn.theme, defaultVariants = viewPropsIn.defaultVariants, nonTamaguiProps = _object_without_properties(viewPropsIn, [
      "asChild",
      "children",
      "themeShallow",
      "spaceDirection",
      "onPress",
      "onLongPress",
      "onPressIn",
      "onPressOut",
      "onHoverIn",
      "onHoverOut",
      "onMouseUp",
      "onMouseDown",
      "onMouseEnter",
      "onMouseLeave",
      "onFocus",
      "onBlur",
      "separator",
      "forceStyle",
      "onClick",
      "theme",
      "defaultVariants"
    ]), viewProps = nonTamaguiProps;
    !isTaggable && props.forceStyle && (viewProps.forceStyle = props.forceStyle), isHOC && _themeProp && (viewProps.theme = _themeProp), elementType.acceptTagProp && (viewProps.tag = tagProp);
    var animationStyles, shouldUseAnimation = (
      // if it supports css vars we run it on server too to get matching initial style
      (supportsCSSVars ? willBeAnimatedClient : willBeAnimated) && useAnimations && !isHOC
    );
    if (shouldUseAnimation) {
      var _themeState_state1, animations = useAnimations({
        props: propsWithAnimation,
        // if hydrating, send empty style
        style: splitStylesStyle || {},
        presence,
        componentState: state,
        styleProps,
        theme: (_themeState_state1 = themeState.state) === null || _themeState_state1 === void 0 ? void 0 : _themeState_state1.theme,
        pseudos: pseudos || null,
        staticConfig,
        stateRef
      });
      (isAnimated || supportsCSSVars) && animations && (animationStyles = animations.style, viewProps.style = animationStyles), process.env.NODE_ENV === "development" && time && time(_templateObject11());
    }
    process.env.NODE_ENV === "development" && props.untilMeasured && !props.group && console.warn(`You set the untilMeasured prop without setting group. This doesn't work, be sure to set untilMeasured on the parent that sets group, not the children that use the $group- prop.

If you meant to do this, you can disable this warning - either change untilMeasured and group at the same time, or do group={conditional ? 'name' : undefined}`), process.env.NODE_ENV === "development" && time && time(_templateObject12()), groupName && (nonTamaguiProps.onLayout = (0, import_helpers.composeEventHandlers)(nonTamaguiProps.onLayout, function(e) {
      stateRef.current.group.emit(groupName, {
        layout: e.nativeEvent.layout
      }), !stateRef.current.hasMeasured && props.untilMeasured === "hide" && setState(function(prev) {
        return _object_spread({}, prev);
      }), stateRef.current.hasMeasured = !0;
    })), viewProps = ((_hooks_usePropsTransform = import_setupHooks.hooks.usePropsTransform) === null || _hooks_usePropsTransform === void 0 ? void 0 : _hooks_usePropsTransform.call(import_setupHooks.hooks, elementType, nonTamaguiProps, stateRef, curStateRef.willHydrate)) || nonTamaguiProps, curStateRef.composedRef || (curStateRef.composedRef = (0, import_compose_refs.composeRefs)(function(x) {
      return stateRef.current.host = x;
    }, forwardedRef, import_setElementProps.setElementProps)), viewProps.ref = curStateRef.composedRef, process.env.NODE_ENV === "development" && !isReactNative && !isText && import_constants.isWeb && !isHOC && import_react.Children.toArray(props.children).forEach(function(item) {
      typeof item == "string" && item !== `
` && console.error("Unexpected text node: ".concat(item, ". A text node cannot be a child of a <View>."));
    }), process.env.NODE_ENV === "development" && time && time(_templateObject13());
    var pseudoGroups = splitStyles.pseudoGroups, mediaGroups = splitStyles.mediaGroups, unPress = function() {
      return setStateShallow({
        press: !1,
        pressIn: !1
      });
    };
    (0, import_react.useEffect)(function() {
      if (!disabled) {
        if (state.unmounted === !0 && hasEnterStyle) {
          setStateShallow({
            unmounted: "should-enter"
          });
          return;
        }
        if (state.unmounted) {
          setStateShallow({
            unmounted: !1
          });
          return;
        }
        var dispose = subscribeToContextGroup({
          disabled,
          componentContext,
          setStateShallow,
          state,
          mediaGroups,
          pseudoGroups
        });
        return function() {
          dispose == null || dispose(), componentSetStates.delete(setState);
        };
      }
    }, [
      state.unmounted,
      disabled,
      pseudoGroups ? Object.keys(_to_consumable_array(pseudoGroups)).join("") : 0,
      mediaGroups ? Object.keys(_to_consumable_array(mediaGroups)).join("") : 0
    ]);
    var runtimePressStyle = !disabled && noClassNames && (pseudos == null ? void 0 : pseudos.pressStyle), runtimeFocusStyle = !disabled && noClassNames && (pseudos == null ? void 0 : pseudos.focusStyle), runtimeFocusVisibleStyle = !disabled && noClassNames && (pseudos == null ? void 0 : pseudos.focusVisibleStyle), attachFocus = !!(runtimePressStyle || runtimeFocusStyle || runtimeFocusVisibleStyle || onFocus || onBlur), attachPress = !!(groupName || runtimePressStyle || onPress || onPressOut || onPressIn || onMouseDown || onMouseUp || onLongPress || onClick || pseudos != null && pseudos.focusVisibleStyle), runtimeHoverStyle = !disabled && noClassNames && (pseudos == null ? void 0 : pseudos.hoverStyle), needsHoverState = !!(groupName || runtimeHoverStyle || onHoverIn || onHoverOut), attachHover = import_constants.isWeb && !!(groupName || needsHoverState || onMouseEnter || onMouseLeave), shouldAttach = !disabled && !props.asChild && !!(attachFocus || attachPress || attachHover || runtimePressStyle || runtimeHoverStyle || runtimeFocusStyle), needsPressState = !!(groupName || runtimePressStyle);
    process.env.NODE_ENV === "development" && time && time(_templateObject14());
    var events = shouldAttach ? _object_spread(_object_spread_props(_object_spread({
      onPressOut: attachPress ? function(e) {
        unPress(), onPressOut == null || onPressOut(e), onMouseUp == null || onMouseUp(e);
      } : void 0
    }, (attachHover || attachPress) && {
      onMouseEnter: function(e) {
        var next = {};
        needsHoverState && (next.hover = !0), needsPressState && state.pressIn && (next.press = !0), setStateShallow(next), onHoverIn == null || onHoverIn(e), onMouseEnter == null || onMouseEnter(e);
      },
      onMouseLeave: function(e) {
        var next = {};
        needsHoverState && (next.hover = !1), needsPressState && state.pressIn && (next.press = !1, next.pressIn = !1), setStateShallow(next), onHoverOut == null || onHoverOut(e), onMouseLeave == null || onMouseLeave(e);
      }
    }), {
      onPressIn: attachPress ? function(e) {
        (runtimePressStyle || groupName) && setStateShallow({
          press: !0,
          pressIn: !0
        }), onPressIn == null || onPressIn(e), onMouseDown == null || onMouseDown(e), import_constants.isWeb && componentSetStates.add(setState);
      } : void 0,
      onPress: attachPress ? function(e) {
        unPress(), import_constants.isWeb && (onClick == null || onClick(e)), onPress == null || onPress(e);
      } : void 0
    }), attachPress && onLongPress && {
      onLongPress: function(e) {
        unPress(), onLongPress == null || onLongPress(e);
      }
    }, attachFocus && {
      onFocus: function(e) {
        pseudos != null && pseudos.focusVisibleStyle ? setTimeout(function() {
          setStateShallow({
            focus: !0,
            focusVisible: !!lastInteractionWasKeyboard.value
          });
        }, 0) : setStateShallow({
          focus: !0,
          focusVisible: !1
        }), onFocus == null || onFocus(e);
      },
      onBlur: function(e) {
        setStateShallow({
          focus: !1,
          focusVisible: !1
        }), onBlur == null || onBlur(e);
      }
    }) : null;
    if (events && !asChild) {
      var _viewProps_focusable;
      Object.assign(events, {
        cancelable: !viewProps.rejectResponderTermination,
        disabled,
        hitSlop: viewProps.hitSlop,
        delayLongPress: viewProps.delayLongPress,
        delayPressIn: viewProps.delayPressIn,
        delayPressOut: viewProps.delayPressOut,
        focusable: (_viewProps_focusable = viewProps.focusable) !== null && _viewProps_focusable !== void 0 ? _viewProps_focusable : !0,
        minPressDuration: 0
      });
    }
    process.env.NODE_ENV === "development" && time && time(_templateObject15()), process.env.NODE_ENV === "development" && debugProp === "verbose" && (0, import_log.log)("events", {
      events,
      attachHover,
      attachPress
    }), (_hooks_useEvents = import_setupHooks.hooks.useEvents) === null || _hooks_useEvents === void 0 || _hooks_useEvents.call(import_setupHooks.hooks, viewProps, events, splitStyles, setStateShallow, staticConfig);
    var direction = props.spaceDirection || "both";
    process.env.NODE_ENV === "development" && time && time(_templateObject16());
    var content = !children || asChild ? children : spacedChildren({
      separator,
      children,
      space,
      direction,
      isZStack,
      debug: debugProp
    });
    if (asChild)
      if (elementType = import_Slot.Slot, 0)
        var webStyleEvents, passEvents;
      else
        Object.assign(viewProps, {
          onPress,
          onLongPress
        });
    process.env.NODE_ENV === "development" && time && time(_templateObject17());
    var useChildrenResult;
    import_setupHooks.hooks.useChildren && (useChildrenResult = import_setupHooks.hooks.useChildren(elementType, content, viewProps, events, staticConfig)), useChildrenResult ? content = useChildrenResult : content = /* @__PURE__ */ (0, import_react.createElement)(elementType, viewProps, content);
    var ResetPresence = config == null || (_config_animations = config.animations) === null || _config_animations === void 0 ? void 0 : _config_animations.ResetPresence;
    ResetPresence && willBeAnimated && (hasEnterStyle || presenceState) && content && typeof content != "string" && (content = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ResetPresence, {
      children: content
    })), process.env.NODE_ENV === "development" && time && time(_templateObject18());
    var groupState = curStateRef.group, subGroupContext = (0, import_react.useMemo)(function() {
      var _splitStyles_style, _splitStyles_style1;
      if (!(!groupState || !groupName))
        return groupState.listeners.clear(), _object_spread_props(_object_spread({}, componentContext.groups), {
          // change reference so as we mutate it doesn't affect siblings etc
          state: _object_spread_props(_object_spread({}, componentContext.groups.state), _define_property({}, groupName, {
            pseudo: import_defaultComponentState.defaultComponentStateMounted,
            // capture just initial width and height if they exist
            // will have top, left, width, height (not x, y)
            layout: {
              width: fromPx((_splitStyles_style = splitStyles.style) === null || _splitStyles_style === void 0 ? void 0 : _splitStyles_style.width),
              height: fromPx((_splitStyles_style1 = splitStyles.style) === null || _splitStyles_style1 === void 0 ? void 0 : _splitStyles_style1.height)
            }
          })),
          emit: groupState.emit,
          subscribe: groupState.subscribe
        });
    }, [
      groupName
    ]);
    if (groupName && subGroupContext && (content = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_ComponentContext.ComponentContext.Provider, _object_spread_props(_object_spread({}, componentContext), {
      groups: subGroupContext,
      children: content
    }))), process.env.NODE_ENV === "development" && time && time(_templateObject19()), content = disableTheme ? content : (0, import_Theme.getThemedChildren)(themeState, content, themeStateProps, !1, stateRef), process.env.NODE_ENV === "development" && time && time(_templateObject20()), process.env.NODE_ENV === "development" && props.debug === "visualize" && (content = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_ThemeDebug.ThemeDebug, {
      themeState,
      themeProps: props,
      children: content
    })), staticConfig.context) {
      var contextProps = staticConfig.context.props;
      for (var key1 in contextProps)
        if (viewProps.style && key1 in viewProps.style || key1 in viewProps) {
          var _viewProps_style;
          overriddenContextProps || (overriddenContextProps = {});
          var _viewProps_style_key;
          overriddenContextProps[key1] = (_viewProps_style_key = (_viewProps_style = viewProps.style) === null || _viewProps_style === void 0 ? void 0 : _viewProps_style[key1]) !== null && _viewProps_style_key !== void 0 ? _viewProps_style_key : viewProps[key1];
        }
    }
    if (overriddenContextProps) {
      var Provider = staticConfig.context.Provider;
      content = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Provider, _object_spread_props(_object_spread({}, contextValue, overriddenContextProps), {
        children: content
      }));
    }
    if (process.env.TAMAGUI_REACT_19 && splitStyles.rulesToInsert.length && (content = /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
      children: [
        content,
        /* lets see if we can put a single style tag per rule for optimal de-duping */
        splitStyles.rulesToInsert.map(function(param) {
          var rules = param.rules, identifier = param.identifier;
          return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("style", {
            // @ts-ignore
            href: "t_".concat(identifier),
            // @ts-ignore
            precedence: "default",
            children: rules.join(`
`)
          }, identifier);
        })
      ]
    })), process.env.NODE_ENV === "development" && debugProp && debugProp !== "profile") {
      var element1 = typeof elementType == "string" ? elementType : "Component", title = "render <".concat(element1, " /> (").concat(internalID, ") with props");
      if (import_constants.isWeb) {
        console.groupCollapsed(title);
        try {
          (0, import_log.log)("viewProps", viewProps), (0, import_log.log)("children", content), typeof window < "u" && ((0, import_log.log)("props in", propsIn, "mapped to", props, "in order", Object.keys(props)), (0, import_log.log)({
            animationStyles,
            classNames,
            content,
            defaultProps,
            elementType,
            events,
            isAnimated,
            isMediaArray,
            isStringElement,
            mediaListeningKeys,
            pseudos,
            shouldAttach,
            shouldAvoidClasses,
            shouldForcePseudo,
            shouldListenForMedia,
            splitStyles,
            splitStylesStyle,
            state,
            stateRef,
            staticConfig,
            styleProps,
            tamaguiConfig,
            themeState,
            viewProps,
            willBeAnimated
          }));
        } catch {
        } finally {
          console.groupEnd();
        }
      } else {
        (0, import_log.log)(title), (0, import_log.log)("state: ", state), import_isDevTools.isDevTools && (0, import_log.log)("viewProps", viewProps), (0, import_log.log)("final styles:");
        for (var key2 in splitStylesStyle)
          (0, import_log.log)(key2, splitStylesStyle[key2]);
      }
      if (debugProp === "break")
        debugger;
    }
    return process.env.NODE_ENV === "development" && time && (time(_templateObject21()), globalThis.willPrint || (globalThis.willPrint = !0, setTimeout(function() {
      delete globalThis.willPrint, time.print(), time = null;
    }, 50))), content;
  });
  staticConfig.componentName && (component.displayName = staticConfig.componentName);
  var res = component;
  (process.env.TAMAGUI_FORCE_MEMO || staticConfig.memo) && (res = /* @__PURE__ */ (0, import_react.memo)(res)), res.staticConfig = staticConfig;
  function extendStyledConfig(extended) {
    return _object_spread_props(_object_spread({}, staticConfig, extended), {
      neverFlatten: !0,
      isHOC: !0,
      isStyledHOC: !1
    });
  }
  function extractable(Component2, extended) {
    return Component2.staticConfig = extendStyledConfig(extended), Component2.styleable = styleable, Component2;
  }
  function styleable(Component2, options) {
    var _Component_render, isForwardedRefAlready = ((_Component_render = Component2.render) === null || _Component_render === void 0 ? void 0 : _Component_render.length) === 2, out = isForwardedRefAlready ? Component2 : /* @__PURE__ */ (0, import_react.forwardRef)(Component2), extendedConfig = extendStyledConfig(options == null ? void 0 : options.staticConfig);
    return out = options != null && options.disableTheme ? out : (0, import_themeable.themeable)(out, extendedConfig), process.env.TAMAGUI_MEMOIZE_STYLEABLE && (out = /* @__PURE__ */ (0, import_react.memo)(out)), out.staticConfig = extendedConfig, out.styleable = styleable, out;
  }
  return res.extractable = extractable, res.styleable = styleable, res;
}
function Unspaced(props) {
  return props.children;
}
Unspaced.isUnspaced = !0;
var getSpacerSize = function(size, param) {
  var tokens = param.tokens;
  size = size === !0 ? "$true" : size;
  var _tokens_space_size, sizePx = (_tokens_space_size = tokens.space[size]) !== null && _tokens_space_size !== void 0 ? _tokens_space_size : size;
  return {
    width: sizePx,
    height: sizePx,
    minWidth: sizePx,
    minHeight: sizePx
  };
}, Spacer = createComponent({
  acceptsClassName: !0,
  memo: !0,
  componentName: "Spacer",
  validStyles: import_helpers.validStyles,
  defaultProps: _object_spread_props(_object_spread({}, import_constants2.stackDefaultStyles), {
    // avoid nesting issues
    tag: "span",
    size: !0,
    pointerEvents: "none"
  }),
  variants: {
    size: {
      "...": getSpacerSize
    },
    flex: {
      true: {
        flexGrow: 1
      }
    },
    direction: {
      horizontal: {
        height: 0,
        minHeight: 0
      },
      vertical: {
        width: 0,
        minWidth: 0
      },
      both: {}
    }
  }
});
function spacedChildren(props) {
  var _childrenList__type, _childrenList_, isZStack = props.isZStack, children = props.children, space = props.space, direction = props.direction, spaceFlex = props.spaceFlex, separator = props.separator, hasSpace = !!(space || spaceFlex), hasSeparator = separator != null;
  if (!(hasSpace || hasSeparator || isZStack))
    return children;
  var childrenList = import_react.Children.toArray(children), len = childrenList.length;
  if (len <= 1 && !isZStack && !(!((_childrenList_ = childrenList[0]) === null || _childrenList_ === void 0 || (_childrenList__type = _childrenList_.type) === null || _childrenList__type === void 0) && _childrenList__type.shouldForwardSpace))
    return childrenList;
  var final = [], _iteratorNormalCompletion = !0, _didIteratorError = !1, _iteratorError = void 0;
  try {
    for (var _iterator = childrenList.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) {
      var _step_value = _sliced_to_array(_step.value, 2), index = _step_value[0], child = _step_value[1], _child_type, isEmpty = child == null || Array.isArray(child) && child.length === 0;
      if (!isEmpty && /* @__PURE__ */ import_react.default.isValidElement(child) && (!((_child_type = child.type) === null || _child_type === void 0) && _child_type.shouldForwardSpace) && (child = /* @__PURE__ */ import_react.default.cloneElement(child, {
        space,
        spaceFlex,
        separator,
        key: child.key
      })), isEmpty || !child || child.key && !isZStack ? final.push(child) : final.push(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_react.Fragment, {
        children: isZStack ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(AbsoluteFill, {
          children: child
        }) : child
      }, index)), !(isUnspaced(child) && index === 0) && !isZStack) {
        var next = childrenList[index + 1];
        next && !isUnspaced(next) && (separator ? (hasSpace && final.push(createSpacer({
          key: "_".concat(index, "_00tmgui"),
          direction,
          space,
          spaceFlex
        })), final.push(/* @__PURE__ */ import_react.default.isValidElement(separator) ? /* @__PURE__ */ import_react.default.cloneElement(separator, {
          key: "sep_".concat(index)
        }) : separator), hasSpace && final.push(createSpacer({
          key: "_".concat(index, "01tmgui"),
          direction,
          space,
          spaceFlex
        }))) : final.push(createSpacer({
          key: "_".concat(index, "02tmgui"),
          direction,
          space,
          spaceFlex
        })));
      }
    }
  } catch (err) {
    _didIteratorError = !0, _iteratorError = err;
  } finally {
    try {
      !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
    } finally {
      if (_didIteratorError)
        throw _iteratorError;
    }
  }
  return process.env.NODE_ENV === "development" && props.debug && (0, import_log.log)("  Spaced children", final, props), final;
}
function createSpacer(param) {
  var key = param.key, direction = param.direction, space = param.space, spaceFlex = param.spaceFlex;
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Spacer, _object_spread({
    size: space,
    direction
  }, typeof spaceFlex < "u" && {
    flex: spaceFlex === !0 ? 1 : spaceFlex === !1 ? 0 : spaceFlex
  }), key);
}
function isUnspaced(child) {
  var t = child == null ? void 0 : child.type;
  return (t == null ? void 0 : t.isVisuallyHidden) || (t == null ? void 0 : t.isUnspaced);
}
var AbsoluteFill = createComponent({
  defaultProps: _object_spread_props(_object_spread({}, import_constants2.stackDefaultStyles), {
    flexDirection: "column",
    position: "absolute",
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    pointerEvents: "box-none"
  })
});
function hasAnimatedStyleValue(style) {
  return Object.keys(style).some(function(k) {
    var val = style[k];
    return val && typeof val == "object" && "_animation" in val;
  });
}
function getMediaState(mediaGroups, layout) {
  return Object.fromEntries(_to_consumable_array(mediaGroups).map(function(mediaKey) {
    return [
      mediaKey,
      (0, import_useMedia.mediaKeyMatch)(mediaKey, layout)
    ];
  }));
}
var fromPx = function(val) {
  return typeof val != "string" ? val : +val.replace("px", "");
}, isDisabled = function(props) {
  var _props_accessibilityState;
  return props.disabled || ((_props_accessibilityState = props.accessibilityState) === null || _props_accessibilityState === void 0 ? void 0 : _props_accessibilityState.disabled) || props["aria-disabled"] || props.accessibilityDisabled || !1;
}, subscribeToContextGroup = function(param) {
  var _param_disabled = param.disabled, disabled = _param_disabled === void 0 ? !1 : _param_disabled, setStateShallow = param.setStateShallow, pseudoGroups = param.pseudoGroups, mediaGroups = param.mediaGroups, componentContext = param.componentContext, state = param.state;
  if (pseudoGroups || mediaGroups) {
    var _componentContext_groups, current = {
      pseudo: {},
      media: {}
    };
    return process.env.NODE_ENV === "development" && !componentContext.groups && console.debug("No context group found"), (_componentContext_groups = componentContext.groups) === null || _componentContext_groups === void 0 ? void 0 : _componentContext_groups.subscribe(function(name, param2) {
      var layout = param2.layout, pseudo = param2.pseudo, persist = function() {
        var group = _object_spread_props(_object_spread({}, state.group), _define_property({}, name, current));
        setStateShallow({
          group
        });
      };
      if (pseudo && (pseudoGroups != null && pseudoGroups.has(String(name))))
        Object.assign(current.pseudo, pseudo), persist();
      else if (layout && mediaGroups) {
        var mediaState = getMediaState(mediaGroups, layout), next = (0, import_createShallowSetState.mergeIfNotShallowEqual)(current.media, mediaState);
        next !== current.media && (Object.assign(current.media, next), persist());
      }
    });
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Spacer,
  Unspaced,
  componentSetStates,
  createComponent,
  isDisabled,
  spacedChildren,
  subscribeToContextGroup,
  useComponentState
});
//# sourceMappingURL=createComponent.js.map
